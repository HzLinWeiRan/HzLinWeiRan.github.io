'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint no-underscore-dangle: ["error", { "allow": ["_transform"] }] */
/* eslint func-names: ["error", "never"] */

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _pathre = require('pathre');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Transform = _stream2.default.Transform;

// const dirMsg = 'Invalid path. Cannot find file to read from.';
var cbMsg = 'Invalid callback function.';
var arrOfobjInvalidMsg = 'Invalid array of objects';
var arrOfobjEmptyMsg = 'Empty array of objects';
var regMsg = 'Invalid regex at: ';
var strMsg = 'Invalid string to be replaced at: ';

// function to generates error as you see.
var errUnit = function errUnit(errMsg) {
  return new Error('\x1B[33m' + errMsg + '\x1B[0m');
};

// check if input is string
var isStr = function isStr(str) {
  return typeof str === 'string';
};

// check if input is regex
var isReg = function isReg(regex) {
  return (typeof regex === 'undefined' ? 'undefined' : _typeof(regex)) === 'object';
};

// gets the phrase length
var phLen = function phLen(phrase) {
  return phrase.length;
};

// create random file name for temp writting.
var genRandomFn = function genRandomFn(dir) {
  var ext = _pathre.get.fileExt(dir);
  if (ext === 'env') return '.env.' + _crypto2.default.randomBytes(2).toString('hex');
  return _crypto2.default.randomBytes(2).toString('hex') + '.' + ext;
};

/**
 *
 * @param {Object}
 * @property {string} - directory
 * @property {number} - arrayOfobj
 * @callback {err~boolean}
 * if found and replaced then true, otherwise false.
 */
var replace = function replace(dir, arrayOfobj, cb) {
  // validate callback, else every error will be handled in callback error
  if (typeof cb !== 'function') throw errUnit(cbMsg);
  // validate file.
  return _fs2.default.open(dir, 'r', function (openErr, fd) {
    if (openErr) return cb(openErr);
    // validate arrayOfobj
    if ((typeof arrayOfobj === 'undefined' ? 'undefined' : _typeof(arrayOfobj)) !== 'object') return cb(errUnit(arrOfobjInvalidMsg));
    // validate arrayOfobj length
    var arrayLen = phLen(arrayOfobj);
    if (arrayLen === 0) return cb(errUnit(arrOfobjEmptyMsg));
    // validate the objects inside.
    for (var i = 0; i < arrayLen; i += 1) {
      // validate regMsg in find
      if (!isReg(arrayOfobj[i].regex) && !isStr(arrayOfobj[i].regex)) {
        return cb(errUnit(regMsg + arrayOfobj[i].regex));
      }
      // validate regMsg in replace
      if (!isStr(arrayOfobj[i].replace)) return cb(errUnit(strMsg + arrayOfobj[i].replace));
    }
    // Everything good sir! ****************************************************
    // create array of flags
    var isFlags = [];
    // init arry with default false.
    for (var _i = 0; _i < arrayLen; _i += 1) {
      isFlags[_i] = false;
    } // flags
    var isFoundAll = false;
    function Replace(options) {
      // allow use without new
      if (!(this instanceof Replace)) {
        return new Replace(options);
      }
      // init Transform
      Transform.call(this, options);
    }
    _util2.default.inherits(Replace, Transform);
    Replace.prototype._transform = function (chunk, enc, callback) {
      if (!isFoundAll) {
        var newChunk = chunk.toString();
        for (var _i2 = 0; _i2 < arrayLen; _i2 += 1) {
          if (!isFlags[_i2]) {
            if (newChunk.match(arrayOfobj[_i2].regex)) {
              newChunk = newChunk.replace(arrayOfobj[_i2].regex, arrayOfobj[_i2].replace);
              isFlags[_i2] = true;
            }
          }
        }
        this.push(newChunk);
        if (!isFlags.includes(false)) isFoundAll = true;
      } else this.push(chunk);
      callback();
    };
    var rStream = _fs2.default.createReadStream(dir, {
      encoding: 'utf8'
    });
    // handling streams error.
    rStream.on('error', function (err) {
      return cb(err);
    });
    // create temporary file path for writing tem file when reading.
    var nwPath = _path2.default.join(_pathre.get.directory(dir), genRandomFn(dir));
    var wStream = _fs2.default.createWriteStream(nwPath);
    wStream.on('error', function (err) {
      return cb(err);
    });
    // pipe
    rStream.pipe(Replace()).pipe(wStream);
    // finish reading
    return rStream.on('end', function () {
      // stop writting.
      wStream.end();
      return _fs2.default.unlink(nwPath, function (unErr) {
        if (unErr) return cb(unErr);
        return _fs2.default.rename(nwPath, dir, function (rnErr2) {
          if (unErr) return cb(rnErr2);
          return _fs2.default.close(fd, function () {
            var report = [];
            for (var _i3 = 0; _i3 < arrayLen; _i3 += 1) {
              report[_i3] = {
                isChanged: isFlags[_i3],
                regex: arrayOfobj[_i3].regex,
                replace: arrayOfobj[_i3].replace
              };
            }
            return cb(null, report);
          });
        });
      });
    });
  });
};

exports.default = replace;